# Implementing Tools

Tools provide functionality that LLMs can invoke to take actions or perform computations. Think of them as function calls that extend the LLM's capabilities.

## Tool Fundamentals

Tools are the primary way LLMs interact with your server to perform actions. They have structured schemas that define parameters, types, and constraints, ensuring type-safe interactions.

### Basic Tool Structure

```go
// Create a simple tool
tool := mcp.NewTool("calculate",
    mcp.WithDescription("Perform arithmetic operations"),
    mcp.WithString("operation", 
        mcp.Required(),
        mcp.Enum("add", "subtract", "multiply", "divide"),
        mcp.Description("The arithmetic operation to perform"),
    ),
    mcp.WithNumber("x", mcp.Required(), mcp.Description("First number")),
    mcp.WithNumber("y", mcp.Required(), mcp.Description("Second number")),
)
```

## Tool Definition

### Parameter Types

MCP-Go supports various parameter types with validation:

```go
// String parameters
mcp.WithString("name", 
    mcp.Required(),
    mcp.Description("User's name"),
    mcp.MinLength(1),
    mcp.MaxLength(100),
)

// Number parameters  
mcp.WithNumber("age",
    mcp.Required(),
    mcp.Description("User's age"),
    mcp.Minimum(0),
    mcp.Maximum(150),
)

// Integer parameters
mcp.WithInteger("count",
    mcp.Default(10),
    mcp.Description("Number of items"),
    mcp.Minimum(1),
    mcp.Maximum(1000),
)

// Boolean parameters
mcp.WithBoolean("enabled",
    mcp.Default(true),
    mcp.Description("Whether feature is enabled"),
)

// Array parameters
mcp.WithArray("tags",
    mcp.Description("List of tags"),
    mcp.Items(mcp.StringSchema()),
)

// Object parameters
mcp.WithObject("config",
    mcp.Description("Configuration object"),
    mcp.Properties(map[string]mcp.Schema{
        "timeout": mcp.NumberSchema(),
        "retries": mcp.IntegerSchema(),
    }),
)
```

### Enums and Constraints

```go
// Enum values
mcp.WithString("priority",
    mcp.Required(),
    mcp.Enum("low", "medium", "high", "critical"),
    mcp.Description("Task priority level"),
)

// String constraints
mcp.WithString("email",
    mcp.Required(),
    mcp.Pattern(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`),
    mcp.Description("Valid email address"),
)

// Number constraints
mcp.WithNumber("price",
    mcp.Required(),
    mcp.Minimum(0),
    mcp.ExclusiveMaximum(10000),
    mcp.Description("Product price in USD"),
)
```

## Tool Handlers

Tool handlers process the actual function calls from LLMs.

### Basic Handler Pattern

```go
func handleCalculate(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Extract parameters
    operation := req.Params.Arguments["operation"].(string)
    x := req.Params.Arguments["x"].(float64)
    y := req.Params.Arguments["y"].(float64)
    
    // Perform calculation
    var result float64
    switch operation {
    case "add":
        result = x + y
    case "subtract":
        result = x - y
    case "multiply":
        result = x * y
    case "divide":
        if y == 0 {
            return nil, fmt.Errorf("division by zero")
        }
        result = x / y
    default:
        return nil, fmt.Errorf("unknown operation: %s", operation)
    }
    
    // Return result
    return mcp.NewToolResultText(fmt.Sprintf("%.2f", result)), nil
}
```

### File Operations Tool

```go
func main() {
    s := server.NewMCPServer("File Tools", "1.0.0",
        server.WithToolCapabilities(true),
    )

    // File creation tool
    createFileTool := mcp.NewTool("create_file",
        mcp.WithDescription("Create a new file with content"),
        mcp.WithString("path", 
            mcp.Required(),
            mcp.Description("File path to create"),
        ),
        mcp.WithString("content",
            mcp.Required(), 
            mcp.Description("File content"),
        ),
        mcp.WithString("encoding",
            mcp.Default("utf-8"),
            mcp.Enum("utf-8", "ascii", "base64"),
            mcp.Description("File encoding"),
        ),
    )

    s.AddTool(createFileTool, handleCreateFile)
    server.ServeStdio(s)
}

func handleCreateFile(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    path := req.Params.Arguments["path"].(string)
    content := req.Params.Arguments["content"].(string)
    encoding := req.Params.Arguments["encoding"].(string)
    
    // Validate path for security
    if strings.Contains(path, "..") {
        return nil, fmt.Errorf("invalid path: directory traversal not allowed")
    }
    
    // Handle different encodings
    var data []byte
    switch encoding {
    case "utf-8":
        data = []byte(content)
    case "ascii":
        data = []byte(content)
    case "base64":
        var err error
        data, err = base64.StdEncoding.DecodeString(content)
        if err != nil {
            return nil, fmt.Errorf("invalid base64 content: %w", err)
        }
    }
    
    // Create file
    if err := os.WriteFile(path, data, 0644); err != nil {
        return nil, fmt.Errorf("failed to create file: %w", err)
    }
    
    return mcp.NewToolResultText(fmt.Sprintf("File created successfully: %s", path)), nil
}
```

### Database Query Tool

```go
func handleDatabaseQuery(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    query := req.Params.Arguments["query"].(string)
    params := req.Params.Arguments["params"].([]interface{})
    
    // Validate query for security (basic example)
    if !isSelectQuery(query) {
        return nil, fmt.Errorf("only SELECT queries are allowed")
    }
    
    // Execute query with timeout
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()
    
    rows, err := db.QueryContext(ctx, query, params...)
    if err != nil {
        return nil, fmt.Errorf("query failed: %w", err)
    }
    defer rows.Close()
    
    // Convert results to JSON
    results, err := rowsToJSON(rows)
    if err != nil {
        return nil, fmt.Errorf("failed to process results: %w", err)
    }
    
    return mcp.NewToolResultJSON(map[string]interface{}{
        "query":   query,
        "results": results,
        "count":   len(results),
    }), nil
}

func isSelectQuery(query string) bool {
    trimmed := strings.TrimSpace(strings.ToUpper(query))
    return strings.HasPrefix(trimmed, "SELECT")
}
```

### HTTP Request Tool

```go
func handleHTTPRequest(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    url := req.Params.Arguments["url"].(string)
    method := req.Params.Arguments["method"].(string)
    headers := req.Params.Arguments["headers"].(map[string]interface{})
    body := req.Params.Arguments["body"].(string)
    
    // Create HTTP request
    httpReq, err := http.NewRequestWithContext(ctx, method, url, strings.NewReader(body))
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }
    
    // Add headers
    for key, value := range headers {
        httpReq.Header.Set(key, fmt.Sprintf("%v", value))
    }
    
    // Execute request with timeout
    client := &http.Client{Timeout: 30 * time.Second}
    resp, err := client.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()
    
    // Read response
    respBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }
    
    return mcp.NewToolResultJSON(map[string]interface{}{
        "status_code": resp.StatusCode,
        "headers":     resp.Header,
        "body":        string(respBody),
    }), nil
}
```

## Argument Validation

### Type-Safe Parameter Extraction

```go
func handleValidatedTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Safe parameter extraction with validation
    name, ok := req.Params.Arguments["name"].(string)
    if !ok {
        return nil, fmt.Errorf("name must be a string")
    }
    
    age, ok := req.Params.Arguments["age"].(float64)
    if !ok {
        return nil, fmt.Errorf("age must be a number")
    }
    
    // Optional parameter with default
    enabled := true
    if val, exists := req.Params.Arguments["enabled"]; exists {
        if b, ok := val.(bool); ok {
            enabled = b
        }
    }
    
    // Validate constraints
    if len(name) == 0 {
        return nil, fmt.Errorf("name cannot be empty")
    }
    
    if age < 0 || age > 150 {
        return nil, fmt.Errorf("age must be between 0 and 150")
    }
    
    // Process with validated parameters
    result := processUser(name, int(age), enabled)
    return mcp.NewToolResultJSON(result), nil
}
```

### Custom Validation Functions

```go
func validateEmail(email string) error {
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return fmt.Errorf("invalid email format")
    }
    return nil
}

func validateURL(url string) error {
    parsed, err := url.Parse(url)
    if err != nil {
        return fmt.Errorf("invalid URL format: %w", err)
    }
    
    if parsed.Scheme != "http" && parsed.Scheme != "https" {
        return fmt.Errorf("URL must use http or https scheme")
    }
    
    return nil
}
```

## Result Types

### Text Results

```go
func handleTextTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    message := "Operation completed successfully"
    return mcp.NewToolResultText(message), nil
}
```

### JSON Results

```go
func handleJSONTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    result := map[string]interface{}{
        "status":    "success",
        "timestamp": time.Now().Unix(),
        "data": map[string]interface{}{
            "processed": 42,
            "errors":    0,
        },
    }
    return mcp.NewToolResultJSON(result), nil
}
```

### Multiple Content Types

```go
func handleMultiContentTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    data := map[string]interface{}{
        "name": "John Doe",
        "age":  30,
    }
    
    return &mcp.CallToolResult{
        Content: []mcp.Content{
            {
                Type: "text",
                Text: "User information retrieved successfully",
            },
            {
                Type: "text",
                Text: fmt.Sprintf("Name: %s, Age: %d", data["name"], data["age"]),
            },
        },
    }, nil
}
```

### Error Results

```go
func handleToolWithErrors(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // Return errors for invalid input
    if someCondition {
        return nil, fmt.Errorf("invalid input: %s", reason)
    }
    
    // Or return structured error information
    return &mcp.CallToolResult{
        Content: []mcp.Content{
            {
                Type: "text", 
                Text: "Operation failed",
            },
        },
        IsError: true,
    }, nil
}
```

## Tool Annotations

Provide hints to help LLMs use your tools effectively:

```go
tool := mcp.NewTool("search_database",
    mcp.WithDescription("Search the product database"),
    mcp.WithString("query",
        mcp.Required(),
        mcp.Description("Search query (supports wildcards with *)"),
    ),
    mcp.WithInteger("limit",
        mcp.Default(10),
        mcp.Minimum(1),
        mcp.Maximum(100),
        mcp.Description("Maximum number of results to return"),
    ),
    mcp.WithArray("categories",
        mcp.Description("Filter by product categories"),
        mcp.Items(mcp.StringSchema()),
    ),
    // Add usage examples
    mcp.WithExamples([]mcp.ToolExample{
        {
            Description: "Search for laptops",
            Arguments: map[string]interface{}{
                "query": "laptop*",
                "limit": 5,
                "categories": []string{"electronics", "computers"},
            },
        },
        {
            Description: "Find all products in electronics category",
            Arguments: map[string]interface{}{
                "query": "*",
                "categories": []string{"electronics"},
            },
        },
    }),
)
```

## Advanced Tool Patterns

### Streaming Results

For long-running operations, consider streaming results:

```go
func handleStreamingTool(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // For operations that take time, provide progress updates
    results := []string{}
    
    for i := 0; i < 10; i++ {
        // Simulate work
        time.Sleep(100 * time.Millisecond)
        
        // Check for cancellation
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }
        
        results = append(results, fmt.Sprintf("Processed item %d", i+1))
    }
    
    return mcp.NewToolResultJSON(map[string]interface{}{
        "status":  "completed",
        "results": results,
    }), nil
}
```

### Conditional Tools

Tools that are only available under certain conditions:

```go
func addConditionalTools(s *server.MCPServer, userRole string) {
    // Admin-only tools
    if userRole == "admin" {
        adminTool := mcp.NewTool("delete_user",
            mcp.WithDescription("Delete a user account (admin only)"),
            mcp.WithString("user_id", mcp.Required()),
        )
        s.AddTool(adminTool, handleDeleteUser)
    }
    
    // User tools available to all
    userTool := mcp.NewTool("get_profile",
        mcp.WithDescription("Get user profile information"),
    )
    s.AddTool(userTool, handleGetProfile)
}
```

## Testing Tools

Test your tool implementations thoroughly:

```go
func TestCalculateTool(t *testing.T) {
    tests := []struct {
        name      string
        operation string
        x, y      float64
        expected  string
        wantError bool
    }{
        {"add", "add", 2, 3, "5.00", false},
        {"subtract", "subtract", 5, 3, "2.00", false},
        {"multiply", "multiply", 4, 3, "12.00", false},
        {"divide", "divide", 10, 2, "5.00", false},
        {"divide by zero", "divide", 10, 0, "", true},
        {"invalid operation", "invalid", 1, 2, "", true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := mcp.CallToolRequest{
                Params: mcp.CallToolRequestParams{
                    Name: "calculate",
                    Arguments: map[string]interface{}{
                        "operation": tt.operation,
                        "x":         tt.x,
                        "y":         tt.y,
                    },
                },
            }
            
            result, err := handleCalculate(context.Background(), req)
            
            if tt.wantError {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.Equal(t, tt.expected, result.Content[0].Text)
            }
        })
    }
}
```

## Best Practices

### Security
- Validate all input parameters thoroughly
- Sanitize file paths and database queries
- Implement proper access controls
- Use timeouts for external operations
- Never execute arbitrary code from parameters

### Performance
- Use context cancellation for long operations
- Implement proper timeouts
- Consider caching for expensive operations
- Stream large results when possible

### Error Handling
- Return descriptive error messages
- Use structured error responses when helpful
- Log errors for debugging
- Handle edge cases gracefully

### Documentation
- Provide clear tool descriptions
- Include parameter constraints and examples
- Document expected return formats
- Add usage examples for complex tools

## Next Steps

- **[Prompts](/servers/prompts)** - Learn to create reusable interaction templates
- **[Advanced Features](/servers/advanced)** - Explore typed tools, middleware, and hooks
- **[Testing](/testing)** - Learn comprehensive testing strategies